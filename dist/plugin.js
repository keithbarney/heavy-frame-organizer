// Generated by CoffeeScript 2.7.0
(function() {
  var build, bundleUI, compileCoffeeScript, concatenateJavaScript, debounce, debouncedBuild, execSync, fileTimestamps, fs, path, watchFiles;

  fs = require("fs-extra");

  ({execSync} = require("child_process"));

  path = require("path");

  debounce = require("lodash.debounce");

  // Store last file modification timestamps
  fileTimestamps = {};

  // Function to compile all CoffeeScript files
  compileCoffeeScript = function() {
    var error;
    try {
      console.log("Compiling CoffeeScript...");
      execSync("coffee -c -o dist/ src/");
      return console.log("CoffeeScript compiled successfully.");
    } catch (error1) {
      error = error1;
      console.error("‚ùå CoffeeScript compilation failed:", error.message);
      return process.exit(1);
    }
  };

  // Function to bundle UI files
  bundleUI = function() {
    var bundledHtml, css, error, html;
    try {
      console.log("Bundling UI components...");
      execSync("pug src/ui.pug --out dist/");
      console.log("Pug compiled to dist/ui.html");
      execSync("sass src/styles.sass dist/styles.css");
      console.log("SASS compiled to dist/styles.css");
      html = fs.readFileSync("dist/ui.html", "utf8");
      css = fs.readFileSync("dist/styles.css", "utf8");
      bundledHtml = html.replace("</head>", `<style>${css}</style></head>`);
      fs.writeFileSync("dist/ui.html", bundledHtml, "utf8");
      return console.log("Successfully bundled UI into dist/ui.html!");
    } catch (error1) {
      error = error1;
      console.error("‚ùå UI bundling failed:", error.message);
      return process.exit(1);
    }
  };

  // Function to concatenate JavaScript files
  concatenateJavaScript = function() {
    var concatenatedContent, error, jsFiles;
    try {
      console.log("Concatenating JavaScript files...");
      jsFiles = fs.readdirSync("dist").filter(function(file) {
        return file.endsWith(".js") && file !== "plugin.js";
      });
      concatenatedContent = jsFiles.map(function(file) {
        return fs.readFileSync(path.join("dist", file), "utf8");
      }).join("\n");
      fs.writeFileSync("dist/plugin.js", concatenatedContent, "utf8");
      return console.log("JavaScript files concatenated into dist/plugin.js");
    } catch (error1) {
      error = error1;
      console.error("‚ùå JavaScript concatenation failed:", error.message);
      return process.exit(1);
    }
  };

  // Function to perform the full build process
  build = function() {
    console.log("Running full build process...");
    compileCoffeeScript();
    bundleUI();
    concatenateJavaScript();
    return console.log("‚úÖ Build complete.");
  };

  // Initial build
  build();

  // Debounced build function to prevent redundant triggers
  debouncedBuild = debounce(build, 500);

  // Function to watch for file changes in the src directory
  watchFiles = function() {
    console.log("Watching for changes in the src directory... Press Ctrl+C to stop.");
    return fs.watch("src", {
      recursive: true
    }, function(eventType, filename) {
      var error, filePath, modifiedTime, stats;
      if (filename) {
        filePath = path.join("src", filename);
        try {
          stats = fs.statSync(filePath);
          modifiedTime = stats.mtimeMs;
          // Prevent unnecessary rebuilds by checking for actual file content modifications
          if (fileTimestamps[filePath] && fileTimestamps[filePath] === modifiedTime) { // Skip rebuild if the file hasn't actually changed
            return;
          }
          fileTimestamps[filePath] = modifiedTime;
          console.log(`Detected changes in ${filename}. Scheduling rebuild...`);
          return debouncedBuild();
        } catch (error1) {
          error = error1;
          return console.error("‚ùå Error reading file:", error.message);
        }
      }
    });
  };

  watchFiles();

}).call(this);

// Generated by CoffeeScript 2.7.0
(function() {
  // Ensure the UI is properly loaded with adjustable size
  var loadSpacingValues, organizeFrames;

  figma.showUI(__html__, {
    width: 400,
    height: 400
  });

  // Load previous spacing values from client storage
  loadSpacingValues = function() {
    return Promise.all([figma.clientStorage.getAsync("horizontalSpacing"), figma.clientStorage.getAsync("verticalSpacing")]).then(function([storedHorizontal, storedVertical]) {
      var horizontalSpacing, verticalSpacing;
      horizontalSpacing = storedHorizontal || 0;
      verticalSpacing = storedVertical || 0;
      return figma.ui.postMessage({
        type: "load-spacing",
        horizontalSpacing,
        verticalSpacing
      });
    }).catch(function(error) {
      return console.error("Error loading spacing values:", error);
    });
  };

  loadSpacingValues();

  // Listen for messages from the UI
  figma.ui.onmessage = function(msg) {
    var horizontalSpacing, verticalSpacing;
    console.log("Message received from UI:", msg);
    if ((msg != null ? msg.type : void 0) === "organize-frames") {
      verticalSpacing = parseFloat(msg != null ? msg.verticalSpacing : void 0) || 0;
      horizontalSpacing = parseFloat(msg != null ? msg.horizontalSpacing : void 0) || 0;
      // Save values asynchronously
      Promise.all([
        figma.clientStorage.setAsync("horizontalSpacing",
        horizontalSpacing).catch(function(error) {
          return console.error("Error saving horizontal spacing:",
        error);
        }),
        figma.clientStorage.setAsync("verticalSpacing",
        verticalSpacing).catch(function(error) {
          return console.error("Error saving vertical spacing:",
        error);
        })
      ]);
      return organizeFrames(verticalSpacing, horizontalSpacing);
    }
  };

  // Function to organize Figma elements
  organizeFrames = function(verticalSpacing, horizontalSpacing) {
    var allSelected, columnHeight, i, j, k, l, len, len1, len2, len3, mainComponent, mainComponents, maxColumnHeight, node, ref, ref1, ref2, ref3, relatedSubComponents, section, sectionXOffset, sectionYOffset, sections, subComponent, subComponents, xOffset, yOffset;
    console.log("Scanning elements on the Figma page...");
    mainComponents = [];
    subComponents = [];
    sections = [];
    ref = figma.currentPage.children;
    // Identify main component, sub-components, and sections
    for (i = 0, len = ref.length; i < len; i++) {
      node = ref[i];
      console.log("Checking:", node.name, "Type:", node.type);
      if (node.type === "COMPONENT" || node.type === "COMPONENT_SET") {
        if (node.name.startsWith(".")) {
          subComponents.push(node); // Store sub-components
        } else {
          mainComponents.push(node); // Store main components
        }
      }
      if (node.type === "SECTION") {
        sections.push(node); // Store sections
      }
    }
    
    // Move the main components
    if (mainComponents.length > 0) {
      console.log(`Organizing ${mainComponents.length} main components`);
      allSelected = [];
      xOffset = 0;
      maxColumnHeight = 0;
      ref1 = mainComponents.sort(function(a, b) {
        return a.name.localeCompare(b.name);
      });
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        mainComponent = ref1[j];
        console.log("Setting main component:", mainComponent.name, `to (${xOffset}, 0)`);
        mainComponent.x = xOffset;
        mainComponent.y = 0;
        allSelected.push(mainComponent);
        yOffset = mainComponent.height + verticalSpacing;
        relatedSubComponents = subComponents.filter(function(sub) {
          return sub.name.trim().startsWith(`.${mainComponent.name.trim()}`);
        });
        ref2 = relatedSubComponents.sort(function(a, b) {
          return a.name.localeCompare(b.name);
        });
        for (k = 0, len2 = ref2.length; k < len2; k++) {
          subComponent = ref2[k];
          console.log("Moving sub-component:", subComponent.name, `to (${xOffset},${yOffset})`);
          subComponent.x = xOffset;
          subComponent.y = yOffset;
          yOffset += subComponent.height + verticalSpacing;
          allSelected.push(subComponent);
        }
        columnHeight = yOffset;
        if (columnHeight > maxColumnHeight) {
          maxColumnHeight = columnHeight;
        }
        xOffset += mainComponent.width + horizontalSpacing;
      }
      sectionXOffset = xOffset;
      sectionYOffset = 0;
      ref3 = sections.sort(function(a, b) {
        return a.name.localeCompare(b.name);
      });
      for (l = 0, len3 = ref3.length; l < len3; l++) {
        section = ref3[l];
        console.log("Moving section:", section.name, `to (${sectionXOffset},${sectionYOffset})`);
        section.x = sectionXOffset;
        section.y = sectionYOffset;
        sectionYOffset += section.height + verticalSpacing;
        allSelected.push(section);
      }
    } else {
      console.log("No main components found. Sub-components and sections will not be moved.");
    }
    // Refresh the Figma UI
    figma.currentPage.selection = allSelected;
    figma.viewport.scrollAndZoomIntoView(figma.currentPage.selection);
    console.log("Reorganization complete!");
    figma.notify("Main, sub-components, and sections arranged!");
    return figma.closePlugin();
  };

}).call(this);

// Generated by CoffeeScript 2.7.0
(function() {
  document.getElementById("apply").addEventListener("click", function() {
    var horizontalSpacing, ref, ref1, verticalSpacing;
    horizontalSpacing = parseInt((ref = document.getElementById("horizontalSpacing")) != null ? ref.value : void 0, 10) || 0;
    verticalSpacing = parseInt((ref1 = document.getElementById("verticalSpacing")) != null ? ref1.value : void 0, 10) || 0;
    console.log("üì§ Sending to Figma:", {horizontalSpacing, verticalSpacing});
    return parent.postMessage({
      pluginMessage: {
        type: "apply-spacing",
        horizontalSpacing: horizontalSpacing,
        verticalSpacing: verticalSpacing
      }
    }, "*");
  });

}).call(this);
